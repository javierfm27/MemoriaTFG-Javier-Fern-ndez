%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CAPÍTULO 2 - ARQUITECTURA GENERAL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Soluciones tecnológicas}
\label{chap:Arqui}
Este capítulo constará de dos partes. Una primera donde se muestra una visión general de las tecnologías que usaremos para la creación de la página web, y una segunda donde explicamos brevemente cada tecnología utilizada.

    %%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 2.1 - ARQUITECTURA
    %%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Arquitectura general}
\label{sec:arqui}
En cualquier proyecto de desarrollo web existen dos tipos de tecnologías, BackEnd y FrontEnd. Por tanto, antes de exponer la visión general de nuestra web. ¿Qué significan estos dos términos?:
\begin{itemize}
    \item \textbf{BackEnd:} Tecnologías que trabajan en el lado del servidor,es decir, tecnologías en toma de datos, procesarlos, envío al usuario. Sin estas, las tecnologías del \emph{frontEnd} no tendrían nada que mostrar.
    \item \textbf{FrontEnd:} Tal y como hemos comentado, son las tecnologías que se encargan de mostrar el contenido, es decir, tecnologías centradas en el lado de la aplicación como CSS, HTML5, JavaScript.
\end{itemize}
Una vez diferenciada estas capas, en nuestro \emph{BackEnd} podemos diferencias tecnología donde se alojara tanto nuestro contenido web como nuestro código fuente en \emph{GitHub}, tecnología que además proporcionará otras como soporte de problemas (ITS), tecnologías sobre cobertura de código. \\
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{img/arqui_general.png}
    \caption{Arquitectura General de la Web}
    \label{fig:arquiGeneral}
\end{figure}
En la capa \emph{FrontEnd} observamos como todas las tecnologías que colaborarán son aquellas ya conocidascomo HTML5, CSS; donde cuyo objetivo es mostrar contenido y otras nuevas como \emph{Jekyll}. Observando la figura \ref{fig:arquiGeneral} vemos que otras dos tecnologías nos apoyarán en mostrar el funcionamiento del módulo \emph{PyCardio}, una para mostrar la documentación de los módulos(\emph{ReadTheDocs}) y otra donde también se alojará el código fuente siendo así una aplicación de terceros de Python(PyPI).
    %%%%%%%%%%%%%%%%%%%%
    % 2.2 - BackEnd
    %%%%%%%%%%%%%%%%%%%%%
\section{BackEnd}
\label{sec:backend}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % 2.2.1 - CONTROL DE VERSIONES CON GIT. GITHUB
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Control de versiones con Git. GitHub}
\label{subsec:git}
\begin{figure}[h]
    \centering
    \subfloat{
        \includegraphics[scale=0.7]{img/logo_git.png}
        \label{img:logoGit}
    } \hspace{30mm}
    \subfloat{
        \includegraphics{img/logo_github.png}
        \label{img:logoGithub}
    }
\end{figure}
Este proyecto al ser un trabajo de \emph{software libre}, significa que el código sufrirá cambios de distintos autores, por lo que es necesario un sistema de control de versiones. Para que un sistema sea de control de versiones debe proporcionar un mecanismo de almacenamiento de los elementos que se desea gestionar, posibilidad de realizar cambios sobre los elementos almacenados y un registro histórico de las acciones realizadas con cada elemento o conjunto de elementos. \\
El sistema que se ha escogido debido a nuestra arquitectura de almacenamiento de código y por su seguridad, comodidad y velocidad, es \emph{Git}. Una gran diferencia de \emph{Git} respecto a los demás sistemas de control de versiones es la manera de llevar el registro de cambios sobre sus datos, mientras que la mayoría de sistemas almacenan la información como una lista de cambios, en \emph{Git}, cada vez que se realiza un cambio sobre un archivo \emph{Git} hace una instantánea, y guarda una referencia sobre el archivo sin estos cambios. Para ser mas eficiente, si los archivos no han sido modificados, \emph{Git} no almacena el archivo de nuevo. Esta distinción influye en uno de los mayores beneficios de \emph{Git}, las ramificaciones, tema que trataremos a continuación, viendo como trabajar en un proyecto siguiendo una serie de reglas impuestas por \emph{GitFlow}. \\
\textbf{¿Cómo funciona \emph{Git}?}\\
Todo el funcionamiento de este sistema de control de versiones es mayoritariamente local, es decir, no se necesita información de ningún servidor haciendo así que este sistema sea muy rápido respecto a otros que necesitan información remota para sus operaciones. \\
\emph{Git} tiene tres estados para los archivos que trabajamos:
\begin{itemize}
    \item \textbf{Committed}: Este estado indica que los archivos que han sido modificados, se han almacenado de manera segura en la base de datos local.
    \item \textbf{Modified}: Indica que los archivos que han sido modificados, no han sido confirmados, es decir, los archivos no se han almacenado de forma segura en la base de datos local.
    \item \textbf{Staged}: Estado que marca archivos modificados para la siguiente confirmación.
\end{itemize}
Estos tres estados nos lleva a diferenciar las siguientes áreas de trabajo:
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{img/git_states.png}
    \caption{ Esquema de los estados de un repositorio Git}
    \label{fig:gitStates}
\end{figure}
\begin{itemize}
    \item \textbf{Working Directory}: Este área es donde obtenemos la copia del proyecto, lista para usarse o modificarse, sin influir en la copia original.
    \item \textbf{Staged Area}: Área en la que se recoge los cambios que van a realizarse sobre los archivos antes de confirmarse.
    \item \textbf{Git Directory}: Estado de los archivos originales del proyecto, incluidos metadatos. Cuando se confirma un archivo, \emph{Git} toma los cambios del área de preparación (Staged Área) y almacena los cambios nuevos en el directorio \emph{Git}.
\end{itemize}
Por tanto, el flujo que hay que seguir para trabajar con este sistema de control de versiones es el representado en la figura \ref{fig:gitStates}, donde como vemos tras modificar una serie de archivos en el directorio de trabajo preparamos los archivos añadiéndolos al staged area, se confirman los cambios realizados sobre estos, añadiendo así las instantáneas (copias de los archivos con los cambios confirmados) en el directorio \emph{Git}.

Una vez que hemos visto como trabaja \emph{Git} nos queda responder la pregunta de \textit{¿Qué es GitHub?} \emph{GitHub} es una plataforma de desarrollo colaborativo de software para alojar proyectos utilizando los mencionados repositorios \emph{Git}, es decir, aloja el código en la nube y brinda herramientas para el trabajo de equipo en el proyecto. Otra de las características de \emph{GitHub} es el poder contribuir en el desarrollo de software de los demás, algo esencial en cualquier proyecto de software libre. \textit{¿Qué herramientas proporciona para el trabajo en equipo?} \emph{GitHub} proporciona un amplio abanico de funcionalidades , entre ellas, destaca una wiki para el mantenimiento de las versiones de las paǵinas, un sistema de seguimiento de problemas permitiendo al equipo detallar los problemas con lo desarrollado y una herramienta de revisión de código. \\
Antes de dar por finalizada la sección sobre \emph{Git}, debemos hablar sobre \emph{GitFlow}, extensión de \emph{GitHub} que permite un mantenimiento y estrategia para las ramificicaciones en un proyecto de desarrollo. Esta estrategia y mantenimiento se basa en una serie de reglas, donde se destacan dos ramas principales: rama \textit{master}, y rama \textit{develop}.La \textit{master} se usa cada vez que tengamos código para producción y la rama \textit{develop} para el código que conformará la nueva versión del proyecto \\
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.2]{img/git_flow.png}
    \caption{WorkFlow impuesto por la estrategia y mantenimiento de \emph{GitFlow}}
    \label{fig:gitFlow}
\end{figure}
Por tanto, cada vez que se incorpora código a la rama \textit{master}, tenemos nueva versión. A parte de las ramas principales, observando la figura \ref{fig:gitFlow} podemos distinguir tres tipos de ramas auxiliares, donde cada una sigue sus propias reglas:
\begin{itemize}
    \item \textbf{Feature:} Se originan a partir de la rama \textit{develop}, y  se utilizan para incorporar nuevas características a la aplicación.
    \item \textbf{Release:} Rama que se crea al igual que \textit{feature}, a partir de la rama \textit{develop}. En ellas se depura el código el cual se va a pasar a la producción, es decir, a la rama \textit{master}.
    \item \textbf{Hotfix:} Rama cuyo objetivo es parecido al de la rama \textit{feature}, pero esta se origina a partir de la \emph{master}, y los errores que corregimos en esta rama no están planificados a diferencia de la rama \emph{feature}, que sí lo están.
\end{itemize}
De esta manera el uso que daremos de \emph{GitHub} es el de construir un repositorio donde alojaremos el código de nuestro paquete, permitiendo así que cualquiera pueda aportar ideas al proyecto o mejorar el software.
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % 2.2.2 - Issue Tracking System
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ITS (Issue Tracking System)}
\label{subsec:issue}
\emph{GitHub} proporciona un sistema de seguimiento de incidencias (en inglés \textit{issue tracking system}), funcionalidad que permite administrar y mantener una lista de incidentes, al tratarse de \emph{software}, una incidencia será una solicitud de modificación, corrección o mejora. Esta herramienta integrada en \emph{GitHub} permite a cualquier usuario (si el repositorio es público) agregar una incidencia mediante un \emph{ticket}. Estos, se crean mediante una interfaz gráfica que permite escribir la incidencia en texto plano y etiquetar esta según de donde provenga (bug,error de sintaxis,etc). Cualquier usuario puede editar estos \emph{tickets}, pudiendo así cerrarlos, añadir etiquetas. \\
Las ventajas de incorporar un ITS  en un proyecto de \emph{software} son las siguientes:
\begin{itemize}
    \item Tener un único lugar para observar tanto las incidencias creadas por los colaboradores del proyecto como las creadas por los usuarios del \emph{software}.
    \item Categorizar las incidencias, como ya hemos mencionado, mediante etiquetas.
    \item Tener un acceso rápido sobre el historial de una incidencia. Además, herramientas como \emph{GitHub} incorpora un cuadro de búsqueda, permitiendo así que una incidencia no se repita.
\end{itemize}
Así, esta herramienta nos proporcionará corregir aquellos errores o bugs detectados por usuarios de \emph{PyCardio}, donde estos nos informaran mediante la apertura de \emph{tickets}.

        %%%%%%%%%%%%%%%%%%%%%%%%%%
        % WIKI
        %%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Wiki}
\label{subsec:wiki}
Aunque en nuestro proyecto para la creación de documentación usaremos otra herramienta, no hay que dejar pasar por alto, la que nos proporciona \emph{GitHub}.\\
Todo repositorio de \emph{GitHub} viene equipado con una sección para alojar documentación, llamado wiki.\footnote{Wiki alude al nombre que recibe una comunidad virtual, cuyas páginas pueden ser editadas directamente desde el navegador, donde los mismos usuarios crean, modifican, corrigen o eliminan contenidos que, generalmente, comparten}.Estas wikis se generan mediante texto de marcado \footnote{Este lenguaje puede ser \emph{MarkDown}, lenguaje utilizado para la escritura de ficheros de documentación como \texttt{README.md}} o cualquier otro formato que soporte la creación de wikis. El objetivo por tanto de esta sección es informar de como se ha diseñado, cómo instalar, manifiestos sobre sus principios básicos, objetivos y como usar detalladamente el código al cual pertenece el repositorio, escribir una buena documentación ayuda a otros a usar y a que se extienda dicho proyecto.

        %%%%%%%%%%%%%%%%%%%%%%%%%%
        % AUTOMATED TOOLS
        %%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Automated tools}
\label{subsec:autotools}
\emph{GitHub} además de las funcionalidades que hemos tratado, este ofrece un gran abanico de APIs para la gestión de proyecto, donde estas son automáticas. \emph{GitHub} ofrece estas de manera categórica, cada categoría se centra en una funcionalidad distinta aunque más de una herramienta ofrece diversos servicios, las más importantes son las siguientes:
\begin{table}[H]
    \centering
    \resizebox{\textwidth}{!}{
    \begin{tabular}{| l | l |}
        \hline
        \textbf{Categoría} & \textbf{Descripción}  \\ \hline
        Code quality & Automatiza revisión de código con revisión de estilos y coberturas de pruebas . \\ \hline
        Code review & Herramientas que aseguran que el código sigue un estandár de calidad adecuado \\ \hline
        Continuous Integration & Para construir y probar el código para cada push que se realiza, evitando errores en la producción \\ \hline
        Dependency management & Protege y gestiona las dependencias de terceros \\ \hline
        Monitoring & Monitoiza el impacto de los cambios en el código, mide rendimiento y errores \\ \hline
        Security & Para encontrar, arreglar y prevenir  \\ \hline
    \end{tabular}
    }
    \caption{Categorías de herramientas para la gestión de proyectos en \emph{GitHub}}
    \label{tab:cagGitHub}
\end{table}
Una herramienta que engloba varias de estas funcionalidades es Code Coverage (\emph{CodeCov}). Es una herramienta que nos permite medir la cobertura de código, es decir, mide en que grado el código fuente de un programa ha sido comprobado (testeado). Además esta cobertura es mostrada mediante representaciones visuales y gráficos de evolución. Cuando usamos \emph{CodeCov} usa un porcentaje indicando cuanto código está cubierto. Para el cálculo de esta medida \emph{CodeCov} se distinguen tres terminos que influyen de manera distinta en el cálculo de este:
\begin{itemize}
    \item \textbf{Hit: } Indica que código fuente ha sido ejecutado por pruebas de test.
    \item \textbf{Partial: } Parte del código fuente que no es comprobado (\emph{testeado}) por un bloque de pruebas, es decir, ramificaciones de código (p.ej. sentencia \emph{if-else}).
    \item \textbf{Miss: } Código no comprobado por un bloque de pruebas.
\end{itemize}
Así el cálculo de cobertura es la relación: $coverage = hits / (sum\ of\ hit + partial + miss)$ \\
Tras este cálculo tal y como hemos mencionado, \emph{CodeCov} ofrece una medida visual de esta cobertura, con la interfaz el desarrollador puede ver que parte de código debe cubrir en sus siguientes bloques de pruebas. \\
Otro servicio en el que podemos integrar nuestro proyecto y que no debemos pasar por alto es \emph{Travis-CI}, servidor de integración continua en la nube donde podemos vincular nuestra cuenta de GitHub, donde se encarga de realizar las tareas planificadas por cada push & commit que hagamos en alguno de nuestros repositorios de nuestra cuenta. La mayor ventaja que aporta \emph{Travis-CI} es la de probar nuestras librerías y/o aplicaciones con distintas configuraciones sin tener que instalarlas localmente.
    %%%%%%%%%%%%%%%%%%%%
    % 2.3 - FRONTEND
    %%%%%%%%%%%%%%%%%%%
\section{FrontEnd}
\label{sec:frontEnd}
        %%%%%%%%%%%%%%%%%%%%%%%
        % HTML5
        %%%%%%%%%%%%%%%%%%%%%%%
\subsection{HTML5}
\label{sec:html}
HTML (Hiper Text Markup Language) hace referencia al lenguaje de marcado para la elaboración de páginas web. Es un estándar que sirve de referencia para creación de páginas web. Este estándar está a cargo de la W3C, organización dedicada a la estandarización de casi todas las tecnologías ligadas al desarrollo web, sobre todo, referente a la escritura y su interpretación. Es un lenguaje sencillo, basado en utilizar etiquetas , que definen el contenido que se mostrará al usuario, a parte de tener estas etiquetas con su respectivo contenido, tenemos  que destacar otro elemento en este lenguaje y son los atributos de etiquetas, que nos permitirán configurar los elementos o ajustar su comportamiento. Los atributos más importantes son \emph{class} e \emph{id}, que se usarán para darle estilo al contenido web mediante CSS y Bootstrap. \\
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{img/logo_html5.png}
\end{figure}
HTML5 es la quinta revisión importante de HTML. Lo más importante de esta revisión es que se especifican dos variantes de sintaxis: HTML y XHTML que esta estará servida como lenguaje XML. Las principales novedades que podemos destacar de la nueva revisión son:
\begin{itemize}
    \item Se mejora el elemento \emph{canvas}
    \item API que permite almacenar datos en el lado del cliente.
    \item Mejora de formularios.
    \item API para la geolocalización.
    \item Nuevos elementos como \texttt{<video>} y \texttt{<audio>} que permite la inclusión de contenido multimedia.
\end{itemize}

        %%%%%%%%%%%%%%%%%%%%%%%%
        % CSS
        %%%%%%%%%%%%%%%%%%%%%%%%
\subsection{CSS}
\label{subsec:css}
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.7]{img/logo_css.png}
    \label{fig:logoCss}
\end{figure}
Cascading Style Sheets (hojas de estilo en español) es un lenguaje usado para definir y crear la presentación de un documento estructurado escrito en HTML o XML2. La W3C se encarga de elaborar el estándar que finalmente han optado por seguir todos los navegadores. La sintaxis es muy sencilla , se basa en asignar un valor a una propiedad, estas reglas se pueden establecer en un documento aparte o en la cabecera de un documento HTML tras el elemento \texttt{<style>}. La idea fundamental de CSS reside en separar la estructura del documento de la vista del mismo.

        %%%%%%%%%%%%%%%%%%%%%%%%%%
        % BOOTSTRAP
        %%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bootstrap}
\label{subsec:boot}
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{./img/logo_bootstrap.png}
    \label{fig:logoBoot}
\end{figure}
\emph{Bootstrap} son plantillas echas en base HTML5, CSS3, JQuery y JavaScript que permite hacer una página responsiva, es decir, nos permite que una página web se adapte al tamaño del navegador  o en el dispositivo que está siendo mostrada. Este \emph{framework} trae varios elementos con estilos predefinidos fáciles de configurar como botones. La plantilla que utilizamos en el proyecto usa elementos \emph{Bootstrap}.
        %%%%%%%%%%%%%%%%%%%%%%%%%%
        % MARKDOWN
        %%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MarkDown}
\label{subsec:markdo}
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{img/logo_markdown.png}
    \label{fig:logoMd}
\end{figure}
\emph{MarkDown} es un lenguaje de marcado que facilita la aplicación de formato a un texto empleando una serie de caracteres de una forma especial. En principio fue diseñado para elaborar sitios web haciendo que elaborarlos sea más rápido y sencillo que si estuviésemos empleando directamente HTML, pero hoy en día se utiliza para cualquier tipo de texto independientemente de cual vaya a ser su destino, ya que el principal objetivo de la sintaxis de \emph{MarkDown} es hacerla lo más legible posible. \\
Esto hace que \emph{MarkDown} sea realmente dos cosas, por un lado, un lenguaje y por otro, una herramienta de software tal y como dice "Jhon Gruber" (uno de los creadores) en su web oficial \footnote{\url{https://daringfireball.net/projects/markdown/}}.
Las ventajas de usar \emph{MarkDown} son las siguientes:
\begin{itemize}
    \item Escribir webs es más rápido y cómodo. Ventaja que aprovecharemos bastante a la hora de crear actualizar la web del proyecto.
    \item Es más difícil cometer errores de sintaxis.
    \item Perfecto para usarlo con editores de textos minimalistas.
\end{itemize}
        %%%%%%%%%%%%%%%%%%%%%%%%%%
        % LIQUID
        %%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Liquid}
\label{subse:liquid}
\emph{Liquid} es un lenguaje de plantillas de código abierto creado por Shopify y escrito en Ruby. Se utiliza para cargar contenido dinámico en los contenidos de las páginas web.

\subsection*{¿Cómo funciona \emph{Liquid?}}
El código de  \emph{Liquid} se puede categorizar en tres partes:
\begin{itemize}
    \item \textbf{Objetos:} estos objetos indican donde mostrar el contenido en una página. Los objetos y variables estarán denotados por \texttt{\{\{ \}\}}
    \begin{lstlisting}[title=Código 1: Input. Objetos]
    {{ page.title }}
    \end{lstlisting}
    \begin{lstlisting}[title=Código 2: Output. Objetos]
    {{ Liquid Basics }}
    \end{lstlisting}
    \item \textbf{Etiquetas:} Crean la lógica y el control de flujo para las plantillas, vendrán entre llaves y el caracter de porcentaje ( \texttt{\{\%  \%\}} ). El lenguaje utilizado en las etiquetas no produce ningún texto visible, esto significa que puede asignar variables y crear condiciones o bucles sin mostrar nada en la página.
    \begin{lstlisting}[title=Código 3: Input. Etiquetas]
        {% if user %}
            Hello {{ user.name }}!
        {% endif %}
    \end{lstlisting}
    \begin{lstlisting}[title=Código 4: Output. Etiquetas]
        Hello Adam
    \end{lstlisting}
    \item \textbf{Filtros:} Los filtros cambian la salida de un objeto de \emph{Liquid}. Se utilizan dentro de una salida, es decir, entre la doble llave ( \texttt{\{\{ \}\}} ), y vienen separados por \texttt{|}.
    \begin{lstlisting}[title=Código 5: Input. Filtros]
    {{ "/my/fancy/url" | append: ".html" }}
    \end{lstlisting}
    \begin{lstlisting}[title=Código 6: Output. Filtros]
    /my/fancy/url.html
    \end{lstlisting}
\end{itemize}

Como ya hemos mencionado \emph{Liquid} es usado en diversos \emph{frameworks} de contenido web. En nuestro caso, para \emph{Jekyll}, se crearon sus propios objetos, etiquetas y filtros, estableciendo así \emph{Jekyll Liquid}. Para conocer estos, vienen detalladamente explicados  en la página web de  documentación sobre sus plantillas \footnote{\url{https://jekyllrb.com/docs/liquid/}}.

        %%%%%%%%%%%%%%%%%%%%%%%%%%
        % READTHEDOCS
        %%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Read the Docs}
\label{subsec:readthedocs}
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{img/logo_readthedocs.png}
    \label{fig:logoReadThe}
\end{figure}
\emph{Read the Docs} es un portal web gratuito que permite alojar la documentación de un proyecto (principalmente para proyectos \emph{Python}) haciéndola fácil de encontrar y ofreciendo una opción de búsqueda. Simplifica la documentación de manera que este portal te permite generarla, versionar, y alojarla.\\
Las dos principales ventajas que proporciona \emph{Read the Docs} son que nunca estaremos desincronizados con nuestro código y que permite alojar distintas versiones de nuestra documentación. Estas dos ventajas se aprovechan del sistema de control de versiones, donde para la primera, cuando hacemos un 'push' de nuestro código se genera automáticamente la documentación, estando así la documentación actualizada y para la segunda ventaja es tan fácil como tener una rama para cada versión nueva de la documentación. \\
Para ver como generar nuestra propia documentación con \emph{Read The Docs} vamos a seguir los siguientes pasos:
\begin{enumerate}
    \item Vamos a ver que tecnología usaremos para la generación de documentación.
    \item Como importar nuestra documentación.
    \item Como versionar la documentación.
\end{enumerate}
\textbf{Generadores de Documentación} \\
\emph{Read the Docs} usa para generar la documentación \emph{Sphinx} y/o \emph{MkDocs}. \emph{MkDocs} es un generador que se centra en la simplicidad y la rapidez, permite una personalización  sencilla mediante extensiones y temas, utiliza  \emph{MarkDown} \footnote{¿Qué es \emph{MarkDown} \ref{subsec:markdo}}. \emph{Sphinx} en cambio te permite generar páginas web, PDFs, documentos para e-readers, además de la propia documentación; utiliza \emph{ReStructuredText}(otro lenguaje de marcado).\\
\begin{figure}[H]
    \centering
    \subfloat[MkDocs Example]{
        \label{fig:mkdocs}
        \includegraphics[scale=0.85]{img/mkdocs_example.jpeg}
    }
    \subfloat[Sphinx Example]{
        \label{fig:sphinx}
        \includegraphics[scale=0.4]{img/sphinx_example.png}
    }
    \caption{Ejemplos de los generadores de la documentación}
\end{figure}
\textbf{Importar nuestra Documentación}\\
A la hora de importar nuestra documentación debemos tener una cuenta , tras ello, podemos vincular dicha cuenta a la de \emph{GitHub} permitiendo así que \emph{Read the Docs} muestre una lista de repositorios que se pueden importar a \emph{Read the Docs}. A la hora de importar uno de nuestros repositorio, es hora de configurar el \emph{webhook}\footnote{Método de alterar una aplicación o página web, con callbacks personalizados.En este caso son gestionados por \emph{GitHub}, con cada commit o merge, este se lo notifica a \emph{Read the Docs}} de nuestro repositorio, se encargaŕa de notificar cuando hay un cambio en nuestro código fuente para generar de nuevo la documentación.\\
Una vez importado el repositorio y configurado el \emph{webhook}, nuestra documentación se generará automáticamente. ¿Como lo genera \emph{Read the Docs} a partir del repositorio?\\
Lo primero que hace es mirar dos cosas, el tipo de documentación (\emph{Sphinx} o \emph{MkDocs}) y el repositorio. Dependiendo del tipo \emph{Read the Docs} actuará de una manera u otra.
\begin{itemize}
    \item \textbf{Sphinx: } Cuando se escoge este tipo, \emph{Read the Docs} mirará el archivo \texttt{conf.py}, si este no existe, se creará uno. Tras ello, se buscarán archivos con extensión \texttt{.rst} en el directorio \texttt{doc} o \texttt{docs}, si estos no existen, se buscarán en los directorios restantes del proyecto.
    \item \textbf{MkDocs: } Al optar por este tipo, se lee el archivo \texttt{mkdocs.yml}, archivo que debería encontrarse en la raíz del repositorio, de manera que, si no se encuentra se generará uno. En él se indica el directorio donde se encuentran los archivos con extensión \texttt{.md}, archivos a partir de los cuales se creará la documentación.
    Cuando este archivo se generá solo, \emph{Read the Docs} busca automáticamente de forma iterativa en los siguientes directorios \texttt{docs, doc, Doc o book}, una vez que se encuentra el archivo con la extensión mencionada, se añade en \texttt{mkdocs.yml} el directorio desde donde se creará la documentación.
\end{itemize}
\textbf{Como versionar la documentación} \\
Tal y como se mencionó al inicio de este capítulo, \emph{Read the Docs} soporta múltiples versiones de su repositorio. Cuando se importa por primera vez el proyecto se creará la version \emph{latest} apuntando a la rama por defecto de nuestro sistema de control de versiones, en nuestro caso, rama \texttt{master} de nuestro repositorio de \emph{GitHub}. \\
En los casos normales la versión \emph{latest} apuntará al código más actualizado, si en el proyecto se desarrolla en otra rama, se deberá establecer esta como rama por defecto en la interfaz de configuración de \emph{Read the Docs}. \\

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.25]{img/example_RTD.png}
    \caption{Ejemplo de documentación generada por \emph{Read the Docs}}
    \label{fig:exampleRTD}
\end{figure}
Con todo esto tenemos una manera sencilla de generar la documentación de nuestro proyecto de una manera rápida, sencilla, sincronizada con el desarrollo y automática.


        %%%%%%%%%%%%%%%%%%%%%%%%%%
        % PYPI
        %%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{PyPi}
\label{subsec:pypi}
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{img/logo_pypi.jpg}
    \label{fig:logoPypi}
\end{figure}
\emph{PyPI} ( o Python Package Index) es el repositorio de \emph{software} oficial  para aplicaciones de terceros. Los desarrolladores de Python pretenden que sea un catálogo de exhaustivo de todos los paquetes de código abierto que hay de Python. Normalmente, si un proyecto escrito en Python no está empaquetado o almacenado en \emph{PyPI}  es difícil que este sea encontrado por otros desarrolladores y que este se utilice en sus proyectos, es más, si un proyecto no se encuentra en esta plataforma puede considerarse como una sospecha sustancial de estar mal gestionado, no estar listo para su puesta en libertad o que ha sido abandonado.  \\
Para poder alojar un proyecto en \emph{PyPI} hay que seguir unas ciertos pasos a la hora de crear  el módulo python. Estas pasos consisten en añadir los archivos necesarios, una estructura necesaria para crear el módulo y finalmente subirlo al repositorio \emph{PyPI}. Se pueden resumir en lo siguiente:
\begin{enumerate}
    \item Se crea una estructura de archivos, donde \texttt{example_pkg} es mi proyecto de ejemplo:
    \begin{lstlisting}[language=python]
        /example_pkg
            /example_pkg
                __init__.py
                module.py
        setup.py
        LICENSE
        README.md
    \end{lstlisting}
    Donde \texttt{\_\_init\_\_.py} es utilizado para marcar que el  es un paquete de Python. Es decir, que puedo realizar un \texttt{import module.py}.
    \item Se crea el archivo \texttt{setup.py}. Este archivo es el script de compilación para \emph{setuptools}.
    \item Creación de \texttt{README.md}, dando una breve descripción del proyecto y en qué consiste.
    \item Creación de una Licencia, ya que es importante indicar a los usuarios que instalan el módulo bajo que condiciones pueden usar el paquete.
    \item El siguiente paso es generar paquetes de distribución para el paquete.
    \item El último paso por tanto es la carga de los archivos de distribución.
\end{enumerate}
Al ser nuestro proyecto un módulo de código libre, deberemos seguir estos pasos para tener \emph{PyCardio} en el repositorio oficial.

        %%%%%%%%%%%%%%%%%%%%%%%%%%
        % GITHUB PAGES & Jekyll
        %%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{GitHub Pages y Jekyll}
\label{subsec:githubJekyll}
\emph{GitHub Pages} y \emph{Jekyll} se usan conjuntamente para generar sitios web estáticos , donde \emph{Jekyll} se encarga de generar los sitios web y \emph{GitHub Pages} de servicio de alojamiento. Ambos servicios están integrados. Para explicar como trabajan ambos servicios, vamos a tratarlos primero por separado.

\subsection*{GitHub Pages}
\label{subsec:githubpages}
Es un servicio de alojamiento web que ofrece \emph{GitHub}, se usa para alojar sitios web estáticos usando directamente un repositorio \emph{Git}. Para aclarar la principal ventaja de \emph{GitHub Pages} frente a otros servidores vamos a definir que es una pagina web estática y que se diferencia respecto a una página web dinámica. \\
\textbf{¿Qué es una página web estática?}\\
Una página web estática es aquel documento web que muestra el mismo contenido para todos los usuarios, es decir, que no es personalizable o no hay elección de interactuar con ella para ordenar, ocultar o modificar contenido (páginas dinámicas). Una de las ventajas principales de este tipo de páginas es lo económico que resulta crearlas, sin tener que usar ningún tipo de programación especial. Estas páginas son útiles para el objetivo de simplemente mostrar contenido. Hay que destacar que la mayor desventaja de generar sitios web estáticos son su actualización haciendo de esta algo tedioso. \\
Una vez aclarado, la ventaja principal, a parte de todas las proporcionadas por ser un repositorio \emph{Git}, es que al no necesitar base de datos para servir el contenido, solo se requiere un servidor web que vaya sirviendo el contenido que se solicita.

\subsection*{Jekyll}
\label{subsec:jekyll}
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.3]{img/logo_jekyll.png}
    \label{img:logoJekyll}
\end{figure}
\emph{Jekyll} es un generador de sitios web estáticos, en vez de trabajar con base de datos, \emph{Jekyll} trabaja con texto plano (MarkDown o Textile) y lenguaje de plantilla (Liquid)  generando la página web. La principal ventaja que podemos inferir de \emph{Jekyll} es que no necesitamos saber HTML, para generar nuestro contenido web, ventaja que contra resta sobre lo tedioso que es tener actualizado un sitio web estático. \\
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{img/jeyll_process.png}
    \caption{Proceso para web básica con Jekyll}
    \label{fig:jekyllProc}
\end{figure}
Tal y como observamos la figura \ref{fig:jekyllProc} el proceso de trabajo para construir webs con \emph{Jekyll} es:
\begin{enumerate}
    \item Creamos un layout o diseño de nuestra página HTML que incluirá  código del lenguaje de programación \emph{Liquid}.
    \item Escribimos nuestro contenido en texto plano (\emph{MarkDown} o \emph{Textile}) donde tendremos un preámbulo indicando el diseño a utilizar para ese post, así como otras características para nuestro contenido HTML.
    \item Ejecutamos \emph{Jekyll} generando nuestro sitio web estático.
\end{enumerate}

Para entender como funcionan estos tres pasos vamos a tratar cada uno por separado dando un  breve resumen apoyado en ejemplos sencillos. Antes de empezar hay que destacar que cuando ejecutamos \emph{Jekyll} sobre nuestro directorio , cuyo fin será el que contenga los archivos de nuestro sitio web estático, establece una estructura creando en nuestra raíz del proyecto una serie de directorios, cuya función son las siguientes:\\
\begin{itemize}
    \item[] \textbf{\_includes:} En el irán las porciones de código que se repetirán para todos el sitio web (p.ej. footer), se incluirán en nuestro layouts con includes.
    \item[] \textbf{\_layouts:} Directorio que contendrá todas las plantillas creadas para el sitio web.
    \item[] \textbf{\_posts:} Lugar donde irán todos los artículos que iremos escribiendo en texto plano.
    \item[] \textbf{\_drafts:} En esta carpeta guardaremos los borradores de nuestros artículos, es decir, se utiliza para la prueba de código.
    \item[] \textbf{\_site:} Está se genera no al crear el proyecto \emph{Jekyll}, si no al lanzar el servidor, está contendrá todos los HTML montados así como un \textit{index.html} (archivo principal de un sitio web).
    \item[] \textbf{\_config.yml:} Esto no es un directorio, es una archivo, pero también es generado al crear un proyecto \emph{Jekyll} donde en él encontraremos datos de configuración así como indicaciones de qué directorio obtener los datos.
\end{itemize}
Una vez que tenemos claro a que corresponde cada directorio en nuestro proyecto , tratamos a continucación lo mencionando anteriormente, los pasos  de un proyecto \emph{Jekyll}. \\

\textbf{\large{Diseño de Layout}} \\
Layout es una plantilla donde \emph{Jekyll} incrustará el contenido escrito en texto plano. Tal y como hemos comentado antes, estas plantillas deberán almacenarse en el directorio \texttt{\_layout}. En ellas  haremos uso de nuestro código guardado en \texttt{\_include}, un ejemplo como el de incluir un footer al final de mi plantilla \texttt{default.html} es el siguiente:

\begin{lstlisting}[style=htmlcssjs,title=Código 1: default.html]
<!-- default.html -->
<footer>
    {{include footer.html}}
</footer>
\end{lstlisting}
\begin{lstlisting}[style=htmlcssjs,title=Código 2: footer.html]
<!-- footer.html -->
<p>Posted by: Hege Refsnes</p>
<p>Contact information: <a href="mailto:someone@example.com">
  someone@example.com</a>.</p>
\end{lstlisting}
La herramienta que mas optimiza el trabajo a la hora de elaborar estas plantillas de la que hace uso \emph{Jekyll} es \emph{Liquid}. Este lenguaje que trataremos en el siguiente punto hace uso de variables, donde estas son etiquetas, objetos y filtros. Además cualquier archivo \emph{Jekyll} es accesible mediante variables vía \emph{Liquid}. Estas variables pueden ser el título del sitio web (establecido en \texttt{\_config.yml}). La variable más importante es \texttt{\{\{content\}\}}, ya que en ella es donde \emph{Jekyll} incrustará el contenido escrito en texto plano. Un ejemplo sencillo de un layout sería el siguiente:
\begin{lstlisting}[style=htmlcssjs,title=Código 3: Layout Básico]
<!doctype html>
<html lang="en">
  <head>
    {{include head.html}}
  </head>
  <body>
    <nav>
        {{include nav.html}}
    </nav>
    <h1>{{ page.title }}</h1>
    <section>
      {{ content }}
    </section>
    <footer>
        {{ include footer.html }}
    </footer>
  </body>
</html>
\end{lstlisting}
\textbf{\large{Escribiendo contenido}} \\
Una vez que ya tenemos nuestro layout, es hora de crear el contenido con el que poder construir nuestro sitio web. Como ya hemos mencionado, no es necesario tener conocimientos de HTML, solo escribir contenido en texto plano. \\
A la hora de escribirlo la parte más importante es la denominada como \emph{Front Matter}, ya que cualquier documento que lo contenga, \emph{Jekyll} lo tratará como un fichero especial. Esté debe ser el primer elemento de nuestro fichero, y debe seguir la forma de lenguaje \emph{YAML} entre tres guiones.
\begin{lstlisting}
---
layout: post
title: Blogging Like a Hacker
---
\end{lstlisting}
Entre los guiones se pueden definir variables personalizadas  o variables ya definidas que son accesibles en el contenido usando etiquetas \emph{Liquid} y lo serán tanto en los layouts como en el contenido que estamos creando. La más importante de las variables globales predefinidas que existen es la denominada como \textbf{layout}, con ella indicamos que plantilla vamos a utilizar para el contenido que se va a crear tras el \emph{Front Matter} \\
No podemos finalizar esta sección sin mencionar la regla más importante a la hora de crear posts en nuestra sitio web estático. El fichero que creamos con nuestro texto plano debe alojarse en el directorio ya comentado como , \textbf{\_layout}, el nombre de éste debe seguir una regla de formato, que vendrá dada por: \texttt{YEAR-MONTH-DAY-title.MARKUP}, ya que para organizar el contenido de nuestra web \emph{Jekyll} lo organizará por un sistema de directorios con orden cronólogico.  \\
\textbf{\large{Generando la web}}\\
Creada la plantilla y creado el contenido solo queda generar el sitio web, para ello basta con ejecutar \emph{Jekyll}.\\
Una vez que creamos un directorio como nuestro proyecto \emph{Jekyll}, cada vez que queramos generar el contenido HTML, se ejecuta el comando con la opción de lanzar el sitio localmente o solo construirlo teniendo así nuestro sitio web estático.
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{img/jekyll_process2.png}
    \caption{Proceso de Contenido en Jekyll}
    \label{fig:jekyllProc2}
\end{figure}
\begin{lstlisting}[language=sh]
jekyll new #Crea un proyecto Jekyll
jekyll serve #Construye el sitio web y lo sirve localmente en
             #"localhost:1400"
jekyll build #Genera el contenido web
\end{lstlisting}
\subsection*{Jekyll en repositorio GitHub}
\label{subsec:jekandGit}
Ya tenemos nuestro servidor mediante el servicio \emph{GitHub Pages}, y para el contenido \emph{Jekyll}, pero ¿Cómo actualizamos nuestra web?¿Cada vez que creamos contenido es necesario actualizar repositorio y ejecutar \emph{Jekyll} por separado?. \\
\emph{GitHub} funciona con Jekyll, lo que quiere decir que cuando creamos contenido y este lo comprometemos (committed), \emph{Jekyll} se encargaŕa de generar el contenido tal y como hemos mencionado.
